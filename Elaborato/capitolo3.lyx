#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\begin_preamble
% INTESTAZIONI
% -----------------

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\rfoot{\thepage}
\chead{\includegraphics[width=\textwidth]{intestazione.pdf}}


% SFONDO
% ----------

\usepackage{eso-pic,graphicx}
\makeatletter
\newcommand\BackgroundPicture[2]{
\setlength{\unitlength}{1pt}
\put(0,\strip@pt\paperheight){
\parbox[t][\paperheight]{\paperwidth}{
\vfill
\centering\includegraphics[angle=#2]{#1}
\vfill
}
}
}
\makeatother
\end_preamble
\use_default_options true
\master tesi.lyx
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "times" "default"
\font_sans "helvet" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize 12
\spacing double
\use_hyperref true
\pdf_bookmarks false
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3.5cm
\topmargin 3cm
\rightmargin 2cm
\bottommargin 2.5cm
\headheight 2cm
\headsep 0.5cm
\secnumdepth 1
\tocdepth 1
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle empty
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Implementazione
\end_layout

\begin_layout Section
Component & Connector Diagram
\end_layout

\begin_layout Standard
Riportiamo di seguito il diagramma dei Componenti e Connettori che permette
 di descrivere il sistema con una vista dei componenti.
 In particolare evidenziamo i due componenti principali quali SmartLock
 (applicazione sviluppata sul device, iPad e iOS) e Arduino Controller (sistema
 di interfacciamento con il cancello automatico).
 I due componenti comunicano tra loro attraverso un'interfaccia Bluetooth.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename immagini/ccdiagram.png
	lyxscale 35
	scale 35

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Package Diagram Smart Lock
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Package Diagram: MVC
\end_layout

\begin_layout Standard
Per una descrizione semplificata della struttura del sistema si è scelto
 un Package Diagram, questo ci permette di mostrare l'applicazione del pattern
 MVC applicato per lo sviluppo.
\end_layout

\begin_layout Standard
E' possibile identificare infatti le 3 componenti principali:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Model contenente i dati del sistema, collegamenti con il database e procedure
 di accesso al database;
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Controller contenente gli oggetti Controller utilizzati per gestire l'interfacci
amento tra UI e dati dell'applicazione.
 In particolare distinguiamo 3 macro controller per la gestione della UI
 (ViewControllers), comunicazione Bluetooth con il modulo HM-10 (Bluetooth)
 e Controller di Utilities utilizzati per supporto nella definizione della
 GUI;
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
View contiene le viste dell'interfaccia grafica, UIViews ed elementi Custom
 richiamati nella GUI dell'applicazione e delle funzioni di supporto per
 la loro creazione.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename immagini/packagediagram.png
	lyxscale 35
	scale 35

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Package Diagram Smart Lock
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Questo diagramma è collegato ai vari Class Diagram che descrivono nel dettaglio
 Model, View e Controller, mostrati nel paragrafo successivo.
\end_layout

\begin_layout Section
Dettagli Implementativi: Design Patterns
\end_layout

\begin_layout Standard
Per l'implementazione di SmartLock sono stati utilizzati diversi Design
 Pattern tra cui:
\end_layout

\begin_layout Itemize
Singleton
\end_layout

\begin_layout Itemize
Creator
\end_layout

\begin_layout Itemize
Information Expert 
\end_layout

\begin_layout Itemize
Observer
\end_layout

\begin_layout Itemize
Polimorfismo
\end_layout

\begin_layout Subsection
Singleton
\end_layout

\begin_layout Standard
Il design pattern singleton, presentato dalla Gang of Four, è una soluzione
 a problemi ricorrenti relativi alla programmazione ad oggetti.
 In particolare è un Pattern Creazionale utilizzato per ottenere un'unica
 istanza di un oggetto, fornendo un unico punto di accesso globale.
 La classe StyleManager implementata tramite Singleton Pattern prevede la
 scelta di diversi Temi per l'UI dell'applicazione.
 Le funzioni implementate all'interno di tale classe riguardano la creazione
 di elementi dell'User Inferface, riutilizzati nei relativi controller per
 creare gli oggetti dell'interfaccia.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename immagini/singleton-style.png
	lyxscale 45
	scale 45

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
StyleManager con Singleton Pattern
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Tramite la costante shared definiamo un unico punto di accesso alla classe
 StyleManager, che sarà richiamata nei ViewController AccessScreenViewController
 e CodeAccessViewController.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename immagini/cd-views.png
	lyxscale 35
	scale 35

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Class Diagram - Views
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Creator
\end_layout

\begin_layout Standard
Il Pattern Creator fa parte dei Pattern GRASP i quali forniscono in generale
 delle linee guida per l'assegnazione delle responsabilità ad oggetti che
 collaborano all'interno del sistema.
 In particolare il pattern creator definisce chi crea un oggetto e chi deve
 crearne un'istanza.
 La classe DataController è stata implementata utilizzando il pattern Creator
 per l'accesso alle query del database Core Data.
 All'interno dell'oggetto DataManager sono contenute le funzionalità di
 accesso al database (fetch, delete, insert) e tale oggetto è chiamato all'inter
no delle classi che implementano la logica di business per accedere al metodo
 richiesto.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename immagini/creator-data.png
	lyxscale 50
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
DataController con Pattern Creator
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Information Expert
\end_layout

\begin_layout Standard
Dato un oggetto il pattern Information Expert consigna di assegnare ad esso
 solo le responsabilità per cui ha le informazioni necessarie a soddisfare
 la richiesta.
 Nell'applicazione è stato utilizzato il pattern IE all'interno del DataControll
er per far riferimento alla gestione delle classi Utente e Accesso del database,
 questo perchè le informazioni relative a tali oggetti sono contenute all'intern
o delle richieste gestite dal DataController e vengono risolte solamente
 da esso, isolando il resto dell'applicazione dalla responsabilità di doverle
 implementare.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename immagini/cd-model.png
	lyxscale 35
	scale 35

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Class Diagram - Model
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Observer
\end_layout

\begin_layout Standard
Assegna all'oggetto monitorato il ruolo di registrare al suo interno un
 riferimento agli altri oggetti che devono essere avvisati dei cambiamenti
 (osservatori concreti) tramite l'invocazione di un loro metodo.
 Nell'applicazione si è applicato il pattern Observer per in due casi, infatti
 AppViewController monitora due eventi:
\end_layout

\begin_layout Itemize
“receivedMessage” : per ottimizzare la comunicazione bluetooth si è utilizzata
 un'architettura ad eventi, si riceve una risposta solo all'invio di un
 particolare messaggio (apri, chiudi..).
 
\end_layout

\begin_layout Itemize
“deviceConnected”: per notificare l'applicazione dell'evento relativo alla
 presenza del dispositivo bluetooth a cui collegarsi.
 
\end_layout

\begin_layout Subsection
Polimorfismo
\end_layout

\begin_layout Standard
E' stato poi utilizzato il Pattern GRASP relativo al Polimorfismo per la
 realizzazione dei ViewController dato che questi condividevano una stessa
 struttura di base relativa all'interfaccia grafica, da estendere in entrambi
 in base alle esigenze.
 Questo si può osservare anche nel Class Diagram dei controller dove AccessScree
nViewController e CodeAccessViewController ereditano AppViewController e
 in particolare estendono il metodo setupUserInterface() per estendere la
 GUI.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename immagini/cd-controllers.png
	lyxscale 35
	scale 35

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Class Diagram - Controllers
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Progetto Arduino
\end_layout

\begin_layout Standard
Il sottosistema che gestisce l'apertura del cancello automatica è stato
 realizzato, come descritto nel Capitolo 1, utilizzando un progetto Arduino
 che prevede l'utilizzo dei seguenti componenti:
\end_layout

\begin_layout Itemize
Arduino Uno Board
\end_layout

\begin_layout Itemize
Modulo Bluetooth HM-10
\end_layout

\begin_layout Itemize
Relay da collegare al Cancello Automatico
\end_layout

\begin_layout Standard
I programmi di Arduino vengono caricati tramite l'Arduino IDE.
 Il codice caricato viene preso in gestione da un 
\series bold
bootstrapper
\series default
 che però, a differenza degli altri sistemi comuni, rimane in esecuzione
 per tutto il tempo.
 Infatti i programmi per Arduino non hanno main, ma hanno una funzione di
 loop che viene chiamata ripetutamente dal bootstrapper.
 Dalla definizione di Sistema Operativo ricordiamo che: un sistema operativo
 è un programma che viene avviato al momento del boot e rimane in esecuzione
 per tutto il tempo.
 Notiamo quindi che nel caso dell'Arduino il bootstrapper potrebbe essere
 considerato una sorta di sistema operativo, sebbene i programmi abbiano
 accesso diretto all'hardware.
 Il bootstrapper quindi alcune funzioni di un sistema operativo ma non tutte.
 Puo' essere assimilato a un "monitor residente" storicamente in uso nei
 sistemi batch.
\end_layout

\begin_layout Standard
Di fatto l'implementazione di questo sottosistema è stata ottenuta applicando
 il pattern architetturale Sense Compute Control schematizzato nella seguente
 figura.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename immagini/scc-arduino.png
	lyxscale 35
	scale 35

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Arduino Sense Compute Control Pattern Schema
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In particolare distinguiamo i tre componenti principali dell'architettura:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Sense Lettura dei dati provenienti dal modulo Bluetooth HM-10.
 La lettura avviene interrogando il modulo per verificare che questo sia
 attivo e in caso positivo viene letto il valore attraverso la chiamata
 ble.read().
 Il dato letto è una sequenza di caratteri che devono essere manipolati.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Compute Il dato letto dal modulo bluetooth viene modificato ottenendo il
 messaggio di apertura o chiusura, quindi componendo una stringa con i caratteri
 ricevuti.
 Tale stringa può essere di due tipi 
\begin_inset Quotes eld
\end_inset

apri
\begin_inset Quotes erd
\end_inset

 oppure 
\begin_inset Quotes eld
\end_inset

chiudi
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Control Ai dati opportunamente modificati per essere utilizzati viene applicata
 la logica di business che nel nostro caso si traduce nell'invio al relè
 del segnale conforme con i dati letti (apertura o chiusura).
 
\end_layout

\begin_layout Standard
Di seguito riportiamo un Sequence Diagram che descrive il processo di crittazion
e del messaggio di apertura del cancello tramite scambio di messaggi tra
 il microcontrollore e l'applicazione, tramite il modulo bluetooth citato.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename immagini/sequenceArduino.png
	lyxscale 35
	scale 35

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Sequence Diagram - Comunicazione Bluetooth
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Deployment
\end_layout

\begin_layout Subsection
Deployment Diagram
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename immagini/deployment.png
	lyxscale 35
	scale 35

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Deployment Diagram - SmartLock
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Funzionalità Aggiuntiva: Core ML Visual Recognition
\end_layout

\begin_layout Standard
Al termine dello sprint finale dello sviluppo, avvenuto in contesto Agile,
 è stato possibile testare una nuova funizonalità aggiunta al sistema che
 prevede l'integrazione di un algoritmo di Image Recognition basato sulla
 libreria di Machine Learning CoreML.
 Grazie a questa libreria è stato possibile integrare un modello istriuto
 di machile learning nella nostra applicazione.
 In particolare abbiamo utilizzato il modello Visual Recognition di Watson.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename immagini/coreml.png
	lyxscale 35
	scale 35

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
CoreML Image Recognition
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per istruire il modello sono state utilizzate immagini degli utenti.
 
\end_layout

\begin_layout Standard
Attraverso l'aggiunta di questo modello è stato possibile creare una relazione
 tra Utente ed Accesso effettuato con successo, prima nascosta dall'utilizzo
 automatico del FaceID che, per motivi di privacy, non permette di salvare
 informazioni sul volto riconosciuto.
 Utilizzando CoreML e Watson l'applicazione è in grado di autenticare l'utente
 tramite FaceID e consentire l'accesso e contemporaneamente ottenere informazion
i sull'accesso da poter aggiungere nel log di sistema.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename immagini/dbschema.png
	lyxscale 35
	scale 35

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Database Entiry Relationship Diagram
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Conclusioni
\end_layout

\begin_layout Section
Vantaggi dello sviluppo Agile
\end_layout

\begin_layout Standard
Per la realizzazione del progetto Smart Lock sono state applicate le best
 practices di Agile, in un team di sviluppo composto da 4 sviluppatori ed
 in un tempo totale di 2 mesi.
 I vantaggi di utilizzare questo tipo di approccio allo sviluppo software
 sono notevoli, in particolare quelli che sono stati i riscontri maggiori
 nel nostro Team sono:
\end_layout

\begin_layout Itemize
adattamento al cambiamento: il continuo interfacciamento con il cliente
 per la realizzazione del progetto ha fatto si che applicare le tecniche
 agile di sviluppo iterativo facilitassero i vari rework avvenuti nelle
 fasi di analisi e descrizione dell'architettura del progetto.
 Infatti grazie alla produzione veloce di output da presentare al cliente,
 il feedback è stato raccolto in modo estremamente veloce e continuamente
 sfruttato per migliorare il prodotto con ogni iterazione del processo di
 sviluppo.
\end_layout

\begin_layout Itemize
suddivisione del lavoro facilitata dalle iterazioni: l'utilizzo di un approccio
 iterativo ed evolutivo di tipo Agile ha consentito al team di poter collaborare
 in modo efficiente e giornaliero per la risoluzione di problemi e la realizzazi
one delle funzionalità scelte per l'implementazione.
 
\end_layout

\begin_layout Itemize
utilizzo di sistemi di version management distribuiti (GitHub): la scelta
 di utilizzare la piattaforma GitHub per la condivisione del progetto è
 stata dettata non solo dalla familiarità dei team members ma anche dai
 vantaggi di poter lavorare su una clonazione locale del progetto, in modo
 che ogni membro del team avesse pieno accesso all'intero sistema e potesse
 testarne l'intero funzionamento prima di eseguire commit e push sulla repositor
y master.
 Inoltre sistemi come Github (distribuiti) permettono di mantenere sempre
 una copia di backup del sistema da utilizzare in casi di perdita di informazion
e.
 
\end_layout

\begin_layout Itemize
utilizzo di sistemi di comunicazione virtuali e face-to-face: nonostante
 la maggior parte delle decisioni principali del progetto siano state ottenute
 da meeting face-to-face tra i team members, l'implementazione ha fatto
 anche molto uso di moderni software di comunicazione e collaborazione disponibi
li per lo sviluppo software i quali hanno permesso al team di restare in
 continuo contatto virtuale, aumentando la produttività e le ore di lavoro.
 
\end_layout

\begin_layout Standard
In particolare ogni milestone/meeting con il cliente è stato riportato in
 uno Spreadsheet condiviso e aggiornato con i task da completare e i task
 portati a termine e approvati dal cliente.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename immagini/taskmanagement.png
	lyxscale 35
	scale 35

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Work Managment Spreadsheet
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Tramite Github è possibile anche valutare le performance del team sulla
 base di statistiche relative a commit e code frequency basati sui collaboratori
 della repository come mostrato di seguito.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename immagini/git-commits.png
	lyxscale 35
	scale 35

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Github Insights - Commits
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename immagini/git-commits-time.png
	lyxscale 35
	scale 35

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Github Insights - Weekly Commits
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename immagini/git-codefreq.png
	lyxscale 35
	scale 35

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Github Insights - Code Frequency
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Tool Utilizzati
\end_layout

\begin_layout Itemize
Slack
\end_layout

\begin_layout Itemize
Visual Paradigm Enterprise Edition: Teamwork
\end_layout

\begin_layout Itemize
Github (Private Repository)
\end_layout

\begin_layout Itemize
Google Spreadsheet
\end_layout

\begin_layout Section
Implementazioni Future
\end_layout

\begin_layout Standard
Tra le funzionalità ancora da implementare per il progetto SmartLock evidenziamo
 quella di utilizzo del citofono.
 La realizzazione di tale caso d'uso si baserà sul sistema pre-esistente
 nell'appartamento, interfacciandolo con il microcontrollore in modo da
 poterlo controllare tramite la GUI dell'applicazione, senza dover re-implementa
re la parte hardware.
 Questa proposta prevede un'ottimizzazione di sistemi già esistenti, favorendo
 il 
\series bold
riuso
\series default
 di tecnologie funzionanti e testate e riducendo i tempi di produzione che
 si avrebbero dovendo realizzare l'intera architettura ex-novo.
 
\end_layout

\end_body
\end_document
